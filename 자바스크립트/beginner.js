//@@1. 자바스크립트의 역할.
/**
 * 브라우져 전체를 동작시키는 언어이다. (window객체로 다룬다.)
 * 넌 뭘 하는 html요소야!! 라고 동작 부여!!!!!!!!!!!!!!!
 * 이게 종요! 너는 뭘 하는 요소야! 라고 동작을 부여하는 역할.
 

@@@2. 자바스크립트의 위치

 -1 parsing : 한 줄 한 줄 분석하는 과정. 
 처음에 일단 <!doctype> 이 부분부터 html을 파싱하게 된다.
 이후에 style이나 script태그를 만나게 되면 html파싱을 중지한다.
 그리고나서 서버에서 script파일을 다운받게된다.(fetching)

 즉 파싱하다가 파일을 만나면 브라우져가 서버에서 fetching하게된다.
 그리고 executing 

 -2) 위치 header내에!!

 단점 : 내 script파일이 엄청 크면 느려지고 아직 html body는
 읽지도 않은 상태여서 js가 dom을 조작하는데 너무 문제가 생긴다.
 아직 html dom이 생성이 안 됐기 때문이다.

 -3) body태그 제일 아래.
 장점 : html을 전부 파싱하고 js를 불러오는거라서 js가 잘 동작한다.
 단점 : 하지만 js에 의존하는 html문서라면 html파싱 후에
 js파일을 fetching하고 executing하는 시간도 기다려야해서
 오래걸릴 수 있다.
   
-4) head내 + async(파싱과 패치가 동시에 이루어지는데 패치 끝 동시에 executing이 돼서
    parsing이 다 되지않은 html은 읽을 수 없음.)
    0. 브라우져가 html문서를 다운을 받는다.
    1. html파싱하다가.
    2. async를 보면 js파일을 fetching한다 하지만 달라지는 점 병렬로한다!!!
    3. fetching과 ###동시에### html을 파싱을 한다.
    4. 하지만 fetching이 다 되면 파싱을 멈추고 js executing을 한다.
    5. 그리고 나서 main.js를 실행한다.
    6. 그리고 나서 html을 실행을 하게된다.
    7. 그리고 js파일이 여러개라면 스크립트 순서에 상관없이 fetching이 된
    js가 먼저 실행이돼서 순서대로 실행하기 어렵다.
 장점 : html파싱을 하는동안 script fetching이 일어나게돼서 
 js파일을 다운받는 시간동안만큼 시간이 단축된다.

 단점 : 하지만 html전체를 파싱하지 않았기 때문에, js가 읽지 못 하는 
 html이 존재할 수 있다.

-5) head + defer(결론부터 말 하면 이게 제일 좋음.)
0. html다운.
1. html파싱.
2. defer를 보는순간 파싱과 fetching을 동시에 함.(여기까지는 async와 같아.)
3. 하지만 defer는 html파싱을 다 끝내고 나서 executing이 이루어진다.
4. 따라서 시간도 절약되고 못 읽는 html파일도 존재하지 않게된다.
5. 마찬가지로 파일이 여러개라면, fetching이 순서대로 이루어져서
executing도 순서대로 이루어진다.

 따라서 순서에 의존적인 js라면 defer를 이용해야한다.
 parsing이후에 executing을 순서대로 실행한다.

 정리 defer async를 안 써줬을 때는 parsing과 fetching executing이 전부
 따로따로 돼서 시간이 좀 걸림.
 defer와 async의 공통점은 parsing과 fetching이 병렬로 이루어진다는 점.
 하지만 async는 fetching이 끝남과 parsing을 멈추고 executing을 한다.
 그래서 읽지 못 한 html은 실행이 불가. 순서대로 fetching이 되진 않는다.

 그래서 파싱과 패칭이 동시에 되고 파싱을 다 하고 난 후 순서대로 실행이되는
 head내 defer가 가장 안전하고 좋은 방법이다.

//=============== 이제 가장 중요한 값을 다루자!! =============== 
@@@3. 변수
정의 : 어떤 값에 의미를 부여하는 것. 
자바스크립트는 html요소에 역할을 부여하는 언어여서 
html태그를 변수에 저장하거나 다른 값을 저장한다.

변수 선언 키워드 : var(쓰지 마.) let const
1. const : 절대 바뀌지 않는 값을 입력하고싶을 때.
2. let : 변할 수 있는 값.
팁 : 모든 변수를 const로 그리고 변경될 여지가 있다면 let으로 바꿔.

@@4. 자료형(값의 종류!)

1. String(문자열,글자)
- 템플릿 리터럴 : es6부터 나온 새롭게 생긴 문자열 출력 방법!
  백틱을 사용해서 표현을 하며 문자열 내부에 data를 변수로 표현할 수 있음.
  변수 메소드 전부 들어갈 수 있다. ${}플레이스 홀더로 표시가능.

2. Number(모든 숫자.. 정수 실수 다 돼!!)
- 나올 수 있는 값들을 알아보자!!
- 만약 숫자를 0으로 나눈다면 1/0 ==> infinity(무한)
- 문자열을 숫자로 나눈다면? NaN(Not a Number숫자가 아니다!)
  문자열과 숫자는 더할 수 만 있다.(type은 문자열이 됨.)
  (숫자와 관련된 작업을 할 때 반드시 NaN이 아닌지 염두를 하며 작업을 해야함.)

3. Boolean(on off라고 생각해. 맞나 아닌가. 껐나 켜졌나.)

4. Null(값이 존재하지 않는다. 를 의도적으로 표현! 이거 값 없는 변수야!)
null은 객체가 절대로 아니다.

5. Undefined(이 변수에 아직 값이 할당되지 않았어!!)

6. typeof 타입 : 타입을 체크하는 함수이다.

@@5. 알림 창 ==> 사용자에게 알려주는 역할!
1. alert
2. prompt(입력받은 값을 반환한다. 아무것도 입력 안 받으면 null)
입력받은 값은 문자열로 처리돼서 반드시 형 변환이 필요하다!!
3. confirm(사용자에게 다시 되묻는거! 진짜 이거 할거에요?
    확인 취소버튼이 둘 다 있음.) true false로 나뉨!
단점 : 
1.스크립트가 일시정지가 된다.
창을 닫기 전까지는 아무것도 할 수 없다.
2. 스타일링이 불가능하다. 위치 디자인 아무것도 할 수 없음.


@@6. 형 변환.
값을 다룰 때 자료형이 다르면 의도치 않은 값이 출력될 수 있다.

1. 자동 형변환 : 문자열 + 숫자는 원래 있는 거니까 형 변환이 안 되는데,
   js에서는 +를 제외한 숫자 연산자(- % /)는 자동으로 문자열을 숫자로 바꿔줌.
   "3030" - 2 = 3028이 나옴.
- 단점 : 의도하지 않은 값이 나올 수 있다. 따라서 의도적으로 해주는 형 변환이 필요하다.

2. 명시적 형 변환(위에 배운 6가지의 자료형의 값을 내가 원하는 type으로 바꾼다.)
-1) String(value); 문자열 형으로 명시적 형 변환
-2) Number(value) or +value : Number type으로 값 변환.
 보통 prompt처럼 입력받은 값이 String type일 때 자주 사용된다.
 Number(null)은 0  Number(undefined) NaN이 됨 이건 외우자!!!!!!
-3) Boolean(value) : false or true로 값을 바꿔주는데,
    false로 바뀌는 값만 기억한다!!!!!
    숫자0  , 빈문자열"" , null , undefined , NaN 이것만 false로 바뀜.
    '0' " "은 true이니 조심하자!!!!!!!
    그 이외의 값들은 모두 true로 반환한다.

@@@7. 연산자
-1) 줄여서 쓰기(마치 수열!)
num -= 5; //계속 한 번 할 때 마다 5씩 감소!
num += 10;
        let number = 10;
        for(let i=0; i<10; i++){
            number += 5;
            console.log(number);
        }
-2) 증가 && 감소 연산자
값을 1증가 or 1감소!
반복문에서 왜 후위를 쓸까?
후위는 당장 증가시키는거 말고 다음번부터!!! 예약이라고 생각하자!

-3) 비교연산자
=== !== <= >= == != 
### tip : ==는 쓰지말고 ===일치연산자 쓰자!!!!!!!!

-4) 논리 연산자(3가지 || && !(or and not))
이제 값을 다뤘으니 값으로 뭘 판단하는 조건문을 다뤄보자!

&&는 false가 하나라도 있으면 false임.
즉 false를 발견하면 끝냄.

||는 true를 발견하는 즉시 멈춤.

따라서 작업 시간을 줄이려면 &&에게는 false를 빨리 보여주고.
||는 true를 빨리 보여주면 값을 빨리 도출해낼 수 있음.

성능 최적화. 확률이 큰 것부터 작업. 많은 양을 한 번에 덜어낼 수 있다.

 */

/**
 * @@@8. 조건문(if switch)
 * ()내부의 값과 식을 Boolean type으로 구분시킨다!!
 * 
 * if
 * 조건이 적을 때!
 * 
 * @@@9.반복문(같은 작업을 여러 번 반복.)
 * ex) 가장 큰 수를 고를 때(수 비교!)
 * ex) 여러 번 출력을 할 때(출력 반복)
 * 
 * 
 * 1. for(반복 횟수가 정해져있을 때!)
 * for(let i=0; i<10; i++)
 * 초기값은 딱 한 번 만 실행이 된다!!!!
 * 조건에 부합하면 바로 코드로 가.
 * 그리고 나서 i++을 시킴(다음 작업부터 i 1증가.)
 * 
 * i 1이 증가되고 i=1이 됨. 
 * 이런 원리임!!!
 * 
 * 2. while(반복 수가 정해져있지 않을 때!)
 * 일단 무한루프 돌리고 continue or break를 건다!!
 * 이렇게 사용하면 좋음.
 * 숫자가 10이 나올 때 까지 반복해라!! 
 * 
 * @@9. 함수!!!!!!!!!!!!!!!!!!!!!!!!
 * 봐 맨 위에 js는 html요소에 기능을 부여하는 언어라고 했어.
 * 이 기능이 바로 함수야! 함수를 부여하는거야!
 * 어떤 이벤트를 적용했을 때 함수를 부여하는게 js야!
 * 
 * ex) 팝업을 띄운다. 창을 없앤다 띄운다. 결제를 한다.
 * 검색을 한다. 등등 자주 작업되는 기능들을 함수로 분리!
 * 
 * 유지보수가 쉬움 ==> 100군데에서 사용하는 함수인데 
 * 그 함수 선언문만 수정하면 100군데 전체가 수정이 된다.
 * 
 * @@10. 지역변수 전역변수
 * 이후에 객체 배열 this
 */

// let msg = "welcome"; //전역변수!
// console.log(msg);

// function sayHello(name){
//     let msg = "안녕하세요!!"; //지역변수!
//     console.log(msg + `${name}` + "님");
// }
// sayHello("김지성");
// console.log(msg);

// let name = "mike";

