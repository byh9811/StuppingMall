/**
 * ====== < 변수(선언 할당 스코프 ) > ======
 * ==> 선언 할당 스코프(범위) 호이스팅 4개만 알면 끝
 * 
 * 0. 정의 : 변수란 한 마디로 자료에 의미를 부여한 것.
 * ex) const guestCount : 오늘 온 손님 수를 담는 변수.
 * 
 * 
 * ====== < 자료형 > ======
 * 1. primitive type(원시타입)
 * 2. reference type(참조타입)
 * 
 * @@@  << ====== 원시타입의 선언과 할당 과정 ====== >> @@@
 * 
 * -1. 선언(let a;) : 컴퓨터가 아무 메모리 ex)1001번에다가
 * 공간을 할당하고 이름을 설정한다.
 * 
 * -2. 할당(a=3;) : 다른공간 100003번에 3을 넣어주고 그 주소값을가지고
 * 1001번을 찾고 1001번 값에다가 주소값을 직접 넣어준다.
 * 
 * -3. 재할당 : 그 값을 위해서 다시 새로운 공간을 확보하고,
 * 1001번의 주소값을 새로운 값의 주소값으로 교체해준다.
 * 
 * 3과 재할당된 값의 메모리는 사라지지않는다. 
 * 
 * $$$$$$ 정리 $$$$$$
 * 기본형에서는 값을 바꿀 때 주소값을 직접 그대로 바꾼다!
 * 
 * 
 * @@@  << ====== 레퍼런스 타입의 선언과 할당 과정 ====== >> @@@
 * ex) var me = {
 *    name : "김지성",
 *    weight : "65",
 * }
 * -1) 선언 : me를 위한 공간 100번이 할당
 * 
 * -2) 할당 : 5000번의 메모리에 값이 할당되고 me의 값에는 5000번이라는 주소값이 들어감.
 * 
 * 하지만 5000번이라는 공간에는 하나의 값만 담길 수 있는데, 지금 저 객체는 2개의 변수가 필요함
 * 따라서 5000번이 저 2개의 공간이 할당될 수 있는 2개의 공간을 생성하고,
 * 저 2개의 공간에는 지금부터 primitive로 바뀌기 때문에, 위에 설명한 원리와 같게 된다.
 * 
 * ====== primitive vs reference
 * 1. 값을 재할당해줄 때 원시타입은 그 변수의 값에 저장 돼 있는 메모리주소의 값이
 * 직접적으로 변하지만
 * 레퍼런스 타입은 me에 할당된 값은 변하지 않고, 5000번이 가리키는 메모리의 값이 변한다.
 * 여기서 알 수 있는점은 객체의 프로퍼티인 name과 weight는
 * 따로 떼서보면 다시 원시타입이어서 name과weight이 재할당되면,
 * name과 weight에 저장된 메모리는 직접적으로 변함을 알 수 있다. 
 */

let variables = 5;
console.log(variables);